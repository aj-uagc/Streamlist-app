# EZTechMovie - Complete Application Codebase

## Project Structure
```
eztechmovie/
├── client/                     # React Frontend
│   ├── public/
│   │   ├── index.html
│   │   └── manifest.json
│   ├── src/
│   │   ├── components/
│   │   │   ├── Auth/
│   │   │   │   ├── Login.js
│   │   │   │   ├── Register.js
│   │   │   │   └── ForgotPassword.js
│   │   │   ├── Home/
│   │   │   │   ├── HomePage.js
│   │   │   │   ├── MovieCard.js
│   │   │   │   └── FeaturedMovies.js
│   │   │   ├── Movie/
│   │   │   │   ├── MovieDetails.js
│   │   │   │   ├── VideoPlayer.js
│   │   │   │   └── MovieSearch.js
│   │   │   ├── StreamList/
│   │   │   │   ├── StreamListManager.js
│   │   │   │   ├── CreatePlaylist.js
│   │   │   │   └── SharedPlaylists.js
│   │   │   ├── Subscription/
│   │   │   │   ├── SubscriptionPlans.js
│   │   │   │   ├── PlanComparison.js
│   │   │   │   └── BillingHistory.js
│   │   │   ├── Cart/
│   │   │   │   ├── ShoppingCart.js
│   │   │   │   ├── Checkout.js
│   │   │   │   └── PaymentForm.js
│   │   │   ├── Account/
│   │   │   │   ├── Profile.js
│   │   │   │   ├── PaymentMethods.js
│   │   │   │   └── AccountSettings.js
│   │   │   ├── Admin/
│   │   │   │   ├── AdminDashboard.js
│   │   │   │   ├── ContentManagement.js
│   │   │   │   └── UserManagement.js
│   │   │   ├── Support/
│   │   │   │   ├── SupportCenter.js
│   │   │   │   ├── ContactForm.js
│   │   │   │   └── TicketTracker.js
│   │   │   └── Common/
│   │   │       ├── Navbar.js
│   │   │       ├── Footer.js
│   │   │       ├── LoadingSpinner.js
│   │   │       └── ErrorBoundary.js
│   │   ├── hooks/
│   │   │   ├── useAuth.js
│   │   │   ├── useMovies.js
│   │   │   └── useSubscription.js
│   │   ├── services/
│   │   │   ├── api.js
│   │   │   ├── auth.js
│   │   │   ├── movies.js
│   │   │   ├── subscription.js
│   │   │   └── payments.js
│   │   ├── styles/
│   │   │   ├── globals.css
│   │   │   └── components.css
│   │   ├── utils/
│   │   │   ├── constants.js
│   │   │   ├── helpers.js
│   │   │   └── validators.js
│   │   ├── App.js
│   │   ├── index.js
│   │   └── routes.js
│   ├── package.json
│   └── .env
├── server/                     # Node.js Backend
│   ├── controllers/
│   │   ├── authController.js
│   │   ├── movieController.js
│   │   ├── subscriptionController.js
│   │   ├── paymentController.js
│   │   ├── streamListController.js
│   │   ├── adminController.js
│   │   └── supportController.js
│   ├── middleware/
│   │   ├── auth.js
│   │   ├── validation.js
│   │   ├── security.js
│   │   ├── rateLimiting.js
│   │   └── errorHandler.js
│   ├── models/
│   │   ├── User.js
│   │   ├── Movie.js
│   │   ├── Subscription.js
│   │   ├── Payment.js
│   │   ├── StreamList.js
│   │   ├── SupportTicket.js
│   │   └── index.js
│   ├── routes/
│   │   ├── auth.js
│   │   ├── movies.js
│   │   ├── subscriptions.js
│   │   ├── payments.js
│   │   ├── streamlists.js
│   │   ├── admin.js
│   │   └── support.js
│   ├── services/
│   │   ├── authService.js
│   │   ├── movieService.js
│   │   ├── paymentService.js
│   │   ├── emailService.js
│   │   └── encryptionService.js
│   ├── config/
│   │   ├── database.js
│   │   ├── stripe.js
│   │   ├── security.js
│   │   └── env.js
│   ├── utils/
│   │   ├── logger.js
│   │   ├── validators.js
│   │   └── helpers.js
│   ├── tests/
│   │   ├── auth.test.js
│   │   ├── movies.test.js
│   │   └── payments.test.js
│   ├── server.js
│   ├── package.json
│   └── .env
├── database/
│   ├── migrations/
│   │   ├── 001_create_users.sql
│   │   ├── 002_create_movies.sql
│   │   ├── 003_create_subscriptions.sql
│   │   ├── 004_create_payments.sql
│   │   └── 005_create_streamlists.sql
│   └── seeds/
│       ├── users.sql
│       ├── movies.sql
│       └── subscription_plans.sql
├── docs/
│   ├── SRS.md
│   ├── API_DOCUMENTATION.md
│   ├── SECURITY_POLICY.md
│   └── DEPLOYMENT.md
├── docker-compose.yml
├── README.md
├── .gitignore
└── package.json
```

## Core Application Files

### 1. Package.json (Root)
```json
{
  "name": "eztechmovie",
  "version": "1.0.0",
  "description": "Secure streaming and rental movie platform",
  "scripts": {
    "dev": "concurrently \"npm run server\" \"npm run client\"",
    "server": "cd server && npm run dev",
    "client": "cd client && npm start",
    "build": "cd client && npm run build",
    "test": "cd server && npm test",
    "deploy": "npm run build && npm run server:prod"
  },
  "keywords": ["streaming", "movies", "rental", "subscription"],
  "author": "EZTechMovie Team",
  "license": "MIT",
  "devDependencies": {
    "concurrently": "^7.6.0"
  }
}
```

### 2. Client Package.json
```json
{
  "name": "eztechmovie-client",
  "version": "1.0.0",
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.8.0",
    "axios": "^1.3.0",
    "react-query": "^3.39.0",
    "@stripe/stripe-js": "^1.46.0",
    "@stripe/react-stripe-js": "^1.16.0",
    "react-hook-form": "^7.43.0",
    "react-toastify": "^9.1.0",
    "styled-components": "^5.3.6",
    "react-player": "^2.11.0",
    "jwt-decode": "^3.1.2",
    "lodash": "^4.17.21"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "proxy": "http://localhost:5000"
}
```

### 3. Server Package.json
```json
{
  "name": "eztechmovie-server",
  "version": "1.0.0",
  "dependencies": {
    "express": "^4.18.2",
    "mongoose": "^6.8.0",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.0",
    "cors": "^2.8.5",
    "helmet": "^6.0.1",
    "express-rate-limit": "^6.7.0",
    "express-validator": "^6.14.3",
    "dotenv": "^16.0.3",
    "stripe": "^11.6.0",
    "nodemailer": "^6.9.0",
    "multer": "^1.4.5-lts.1",
    "crypto": "^1.0.1",
    "winston": "^3.8.2",
    "compression": "^1.7.4",
    "express-mongo-sanitize": "^2.2.0",
    "xss": "^1.0.14"
  },
  "devDependencies": {
    "nodemon": "^2.0.20",
    "jest": "^29.3.1",
    "supertest": "^6.3.3"
  },
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "jest"
  }
}
```

## Key Implementation Files

### 4. Server.js (Main Backend Entry)
```javascript
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const mongoSanitize = require('express-mongo-sanitize');
const compression = require('compression');
require('dotenv').config();

const authRoutes = require('./routes/auth');
const movieRoutes = require('./routes/movies');
const subscriptionRoutes = require('./routes/subscriptions');
const paymentRoutes = require('./routes/payments');
const streamlistRoutes = require('./routes/streamlists');
const adminRoutes = require('./routes/admin');
const supportRoutes = require('./routes/support');

const errorHandler = require('./middleware/errorHandler');
const logger = require('./utils/logger');

const app = express();

// Security middleware
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'"]
    }
  }
}));

app.use(compression());
app.use(mongoSanitize());

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100 // limit each IP to 100 requests per windowMs
});
app.use('/api/', limiter);

// Stricter rate limiting for auth endpoints
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5,
  message: 'Too many authentication attempts, please try again later.'
});

// CORS
app.use(cors({
  origin: process.env.CLIENT_URL || 'http://localhost:3000',
  credentials: true
}));

app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Database connection
mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/eztechmovie', {
  useNewUrlParser: true,
  useUnifiedTopology: true,
})
.then(() => logger.info('MongoDB connected'))
.catch(err => logger.error('MongoDB connection error:', err));

// Routes
app.use('/api/auth', authLimiter, authRoutes);
app.use('/api/movies', movieRoutes);
app.use('/api/subscriptions', subscriptionRoutes);
app.use('/api/payments', paymentRoutes);
app.use('/api/streamlists', streamlistRoutes);
app.use('/api/admin', adminRoutes);
app.use('/api/support', supportRoutes);

// Health check
app.get('/api/health', (req, res) => {
  res.status(200).json({ status: 'OK', timestamp: new Date().toISOString() });
});

// Error handling
app.use(errorHandler);

const PORT = process.env.PORT || 5000;

app.listen(PORT, () => {
  logger.info(`Server running on port ${PORT}`);
});

module.exports = app;
```

### 5. React App.js (Main Frontend Entry)
```javascript
import React from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { QueryClient, QueryClientProvider } from 'react-query';
import { ToastContainer } from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';

import { AuthProvider, useAuth } from './hooks/useAuth';
import Navbar from './components/Common/Navbar';
import Footer from './components/Common/Footer';
import HomePage from './components/Home/HomePage';
import Login from './components/Auth/Login';
import Register from './components/Auth/Register';
import MovieDetails from './components/Movie/MovieDetails';
import StreamListManager from './components/StreamList/StreamListManager';
import SubscriptionPlans from './components/Subscription/SubscriptionPlans';
import ShoppingCart from './components/Cart/ShoppingCart';
import Profile from './components/Account/Profile';
import AdminDashboard from './components/Admin/AdminDashboard';
import SupportCenter from './components/Support/SupportCenter';
import ErrorBoundary from './components/Common/ErrorBoundary';
import LoadingSpinner from './components/Common/LoadingSpinner';

import './styles/globals.css';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 1,
      staleTime: 5 * 60 * 1000, // 5 minutes
    },
  },
});

// Protected Route Component
const ProtectedRoute = ({ children, adminOnly = false }) => {
  const { user, loading } = useAuth();

  if (loading) return <LoadingSpinner />;
  
  if (!user) return <Navigate to="/login" />;
  
  if (adminOnly && user.role !== 'admin') {
    return <Navigate to="/" />;
  }
  
  return children;
};

function App() {
  return (
    <ErrorBoundary>
      <QueryClientProvider client={queryClient}>
        <AuthProvider>
          <Router>
            <div className="App">
              <Navbar />
              <main className="main-content">
                <Routes>
                  {/* Public Routes */}
                  <Route path="/" element={<HomePage />} />
                  <Route path="/login" element={<Login />} />
                  <Route path="/register" element={<Register />} />
                  <Route path="/movie/:id" element={<MovieDetails />} />
                  <Route path="/plans" element={<SubscriptionPlans />} />
                  
                  {/* Protected Routes */}
                  <Route path="/streamlists" element={
                    <ProtectedRoute>
                      <StreamListManager />
                    </ProtectedRoute>
                  } />
                  <Route path="/cart" element={
                    <ProtectedRoute>
                      <ShoppingCart />
                    </ProtectedRoute>
                  } />
                  <Route path="/profile" element={
                    <ProtectedRoute>
                      <Profile />
                    </ProtectedRoute>
                  } />
                  <Route path="/support" element={
                    <ProtectedRoute>
                      <SupportCenter />
                    </ProtectedRoute>
                  } />
                  
                  {/* Admin Routes */}
                  <Route path="/admin/*" element={
                    <ProtectedRoute adminOnly>
                      <AdminDashboard />
                    </ProtectedRoute>
                  } />
                </Routes>
              </main>
              <Footer />
              <ToastContainer position="top-right" />
            </div>
          </Router>
        </AuthProvider>
      </QueryClientProvider>
    </ErrorBoundary>
  );
}

export default App;
```

### 6. User Model (MongoDB Schema)
```javascript
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const userSchema = new mongoose.Schema({
  firstName: {
    type: String,
    required: [true, 'First name is required'],
    trim: true,
    maxlength: [50, 'First name cannot exceed 50 characters']
  },
  lastName: {
    type: String,
    required: [true, 'Last name is required'],
    trim: true,
    maxlength: [50, 'Last name cannot exceed 50 characters']
  },
  email: {
    type: String,
    required: [true, 'Email is required'],
    unique: true,
    lowercase: true,
    match: [/^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/, 'Please enter a valid email']
  },
  password: {
    type: String,
    required: [true, 'Password is required'],
    minlength: [8, 'Password must be at least 8 characters'],
    select: false
  },
  role: {
    type: String,
    enum: ['user', 'admin'],
    default: 'user'
  },
  subscription: {
    plan: {
      type: String,
      enum: ['individual', 'friendly', 'family', 'basic', 'gold', 'premium'],
      default: null
    },
    status: {
      type: String,
      enum: ['active', 'inactive', 'cancelled', 'expired'],
      default: 'inactive'
    },
    startDate: Date,
    endDate: Date,
    stripeCustomerId: String,
    stripeSubscriptionId: String
  },
  profile: {
    avatar: String,
    dateOfBirth: Date,
    phone: String,
    preferences: {
      genres: [String],
      language: {
        type: String,
        default: 'en'
      },
      notifications: {
        email: { type: Boolean, default: true },
        push: { type: Boolean, default: true }
      }
    }
  },
  watchHistory: [{
    movieId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Movie'
    },
    watchedAt: {
      type: Date,
      default: Date.now
    },
    duration: Number,
    completed: {
      type: Boolean,
      default: false
    }
  }],
  streamLists: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'StreamList'
  }],
  paymentMethods: [{
    stripePaymentMethodId: String,
    last4: String,
    brand: String,
    expiryMonth: Number,
    expiryYear: Number,
    isDefault: {
      type: Boolean,
      default: false
    }
  }],
  security: {
    loginAttempts: {
      type: Number,
      default: 0
    },
    lockUntil: Date,
    passwordResetToken: String,
    passwordResetExpires: Date,
    twoFactorEnabled: {
      type: Boolean,
      default: false
    },
    lastLogin: Date,
    ipAddress: String
  },
  isActive: {
    type: Boolean,
    default: true
  },
  emailVerified: {
    type: Boolean,
    default: false
  },
  emailVerificationToken: String
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Virtual for account lock status
userSchema.virtual('isLocked').get(function() {
  return !!(this.security.lockUntil && this.security.lockUntil > Date.now());
});

// Pre-save middleware to hash password
userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  
  try {
    const salt = await bcrypt.genSalt(12);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error);
  }
});

// Method to compare password
userSchema.methods.comparePassword = async function(candidatePassword) {
  return bcrypt.compare(candidatePassword, this.password);
};

// Method to increment login attempts
userSchema.methods.incLoginAttempts = function() {
  if (this.security.lockUntil && this.security.lockUntil < Date.now()) {
    return this.updateOne({
      $unset: { 'security.lockUntil': 1 },
      $set: { 'security.loginAttempts': 1 }
    });
  }

  const updates = { $inc: { 'security.loginAttempts': 1 } };
  
  if (this.security.loginAttempts + 1 >= 5 && !this.isLocked) {
    updates.$set = { 'security.lockUntil': Date.now() + 2 * 60 * 60 * 1000 }; // 2 hours
  }
  
  return this.updateOne(updates);
};

userSchema.index({ email: 1 });
userSchema.index({ 'subscription.stripeCustomerId': 1 });
userSchema.index({ createdAt: -1 });

module.exports = mongoose.model('User', userSchema);
```

### 7. Authentication Controller
```javascript
const User = require('../models/User');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const crypto = require('crypto');
const { validationResult } = require('express-validator');
const emailService = require('../services/emailService');
const logger = require('../utils/logger');

const generateToken = (payload) => {
  return jwt.sign(payload, process.env.JWT_SECRET, {
    expiresIn: process.env.JWT_EXPIRE || '7d'
  });
};

const sendTokenResponse = (user, statusCode, res) => {
  const token = generateToken({ 
    id: user._id, 
    email: user.email,
    role: user.role 
  });

  const options = {
    expires: new Date(Date.now() + process.env.JWT_COOKIE_EXPIRE * 24 * 60 * 60 * 1000),
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict'
  };

  // Remove password from output
  user.password = undefined;

  res.status(statusCode)
     .cookie('token', token, options)
     .json({
       success: true,
       token,
       data: { user }
     });
};

// @desc    Register user
// @route   POST /api/auth/register
// @access  Public
exports.register = async (req, res, next) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: 'Validation errors',
        errors: errors.array()
      });
    }

    const { firstName, lastName, email, password } = req.body;

    // Check if user already exists
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({
        success: false,
        message: 'User already exists with this email'
      });
    }

    // Create user
    const user = await User.create({
      firstName,
      lastName,
      email,
      password,
      emailVerificationToken: crypto.randomBytes(20).toString('hex')
    });

    // Send verification email
    try {
      await emailService.sendVerificationEmail(user.email, user.emailVerificationToken);
    } catch (emailError) {
      logger.error('Failed to send verification email:', emailError);
      // Continue with registration even if email fails
    }

    logger.info(`New user registered: ${email}`);
    sendTokenResponse(user, 201, res);

  } catch (error) {
    logger.error('Registration error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error during registration'
    });
  }
};

// @desc    Login user
// @route   POST /api/auth/login
// @access  Public
exports.login = async (req, res, next) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: 'Validation errors',
        errors: errors.array()
      });
    }

    const { email, password } = req.body;

    // Check for user
    const user = await User.findOne({ email }).select('+password');
    if (!user) {
      return res.status(401).json({
        success: false,
        message: 'Invalid credentials'
      });
    }

    // Check if account is locked
    if (user.isLocked) {
      return res.status(423).json({
        success: false,
        message: 'Account temporarily locked due to too many failed login attempts'
      });
    }

    // Check password
    const isMatch = await user.comparePassword(password);
    if (!isMatch) {
      await user.incLoginAttempts();
      return res.status(401).json({
        success: false,
        message: 'Invalid credentials'
      });
    }

    // Reset login attempts on successful login
    if (user.security.loginAttempts > 0) {
      await user.updateOne({
        $unset: {
          'security.loginAttempts': 1,
          'security.lockUntil': 1
        },
        $set: {
          'security.lastLogin': new Date(),
          'security.ipAddress': req.ip
        }
      });
    }

    logger.info(`User logged in: ${email}`);
    sendTokenResponse(user, 200, res);

  } catch (error) {
    logger.error('Login error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error during login'
    });
  }
};

// @desc    Get current logged in user
// @route   GET /api/auth/me
// @access  Private
exports.getMe = async (req, res, next) => {
  try {
    const user = await User.findById(req.user.id)
      .populate('streamLists')
      .select('-security');

    res.status(200).json({
      success: true,
      data: { user }
    });
  } catch (error) {
    logger.error('Get user error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

// @desc    Logout user / clear cookie
// @route   GET /api/auth/logout
// @access  Public
exports.logout = (req, res, next) => {
  res.cookie('token', 'none', {
    expires: new Date(Date.now() + 10 * 1000),
    httpOnly: true
  });

  res.status(200).json({
    success: true,
    message: 'Successfully logged out'
  });
};

// @desc    Forgot password
// @route   POST /api/auth/forgotpassword
// @access  Public
exports.forgotPassword = async (req, res, next) => {
  try {
    const { email } = req.body;
    
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'No user found with that email'
      });
    }

    // Generate reset token
    const resetToken = crypto.randomBytes(20).toString('hex');
    
    // Hash token and set to resetPasswordToken field
    user.security.passwordResetToken = crypto
      .createHash('sha256')
      .update(resetToken)
      .digest('hex');
      
    user.security.passwordResetExpires = Date.now() + 10 * 60 * 1000; // 10 minutes
    
    await user.save();

    // Send reset email
    try {
      await emailService.sendPasswordResetEmail(user.email, resetToken);
      
      res.status(200).json({
        success: true,
        message: 'Password reset email sent'
      });
    } catch (emailError) {
      user.security.passwordResetToken = undefined;
      user.security.passwordResetExpires = undefined;
      await user.save();
      
      logger.error('Email send error:', emailError);
      return res.status(500).json({
        success: false,
        message: 'Email could not be sent'
      });
    }

  } catch (error) {
    logger.error('Forgot password error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

// @desc    Reset password
// @route   PUT /api/auth/resetpassword/:resettoken
// @access  Public
exports.resetPassword = async (req, res, next) => {
  try {
    // Get hashed token
    const resetPasswordToken = crypto
      .createHash('sha256')
      .update(req.params.resettoken)
      .digest('hex');

    const user = await User.findOne({
      'security.passwordResetToken': resetPasswordToken,
      'security.passwordResetExpires': { $gt: Date.now() }
    });

    if (!user) {
      return res.status(400).json({